<!DOCTYPE HTML>
<html >
<head>
  <style>
    html, body {
      width:  100%;
      height: 100%;
      margin: 0px;
      border: 0;
      overflow: hidden; /* Deshabilita las barras de desplazamiento */
      display: block;   /* Sin contenido flotantes a los lados */
    }     
    #canvas-holder {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0px;
      left: 0px;
    }
    #webglcanvas {
      width: 100%;
      height: 100%;
      border: 0px;
    }
  </style>  
  <title>Escena en WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
</head>
  <body>
      <div id="content">

      <div id="canvas-holder">
      <canvas id="webglcanvas" width="1920" height="1080"></canvas>
      </div>

      </div>

      <!--
        /***************************************************************************/
        /* Se definen los códigos shaders.                                         */
        /***************************************************************************/
      -->
      <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec3 aVertices;
        layout(location = 1) in vec4 aColores;
        out vec4 vColores;
        void main() {
          vColores = aColores;  
          gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
        }
      </script>

      <script id="fs" type="fragment">
        #version 300 es
        precision highp float;
        in vec4 vColores;
        out vec4 color;
        void main() {
            color = vColores;
        }
      </script>
	
      <script>
        "use strict";

        /* Variables globales */
        var canvas;
        var programaID;
        var gl;
        var cubo, tronco;
        var montana, valle, lago, cielo;


        /* Variables Uniformes */
        var uMatrizProyeccion; 
        var uMatrizVista;
        var uMatrizModelo;

        /* Matrices */
        var MatrizProyeccion = new Array(16);
        var MatrizVista = new Array(16);
        var MatrizModelo = new Array(16);

        /* Para la interacción */
        var rotX = 0;
        var rotY = 0;
        var rotZ = 0;
        var antX;
        var antY;
        const INCX = 0.3;
        const INCY = 0.2;
        const INCZ = 0.4;
        var incX = 0;
        var incY = 0;
        var incZ = 0;
        var boton_izq_presionado = false;

        var tiempo_real, fin, duracion;
        var inicio = Date.now(); // Tiempo Inicial
        const PERIODO_MOVIMIENTO = 0.01; // 1/60 = 0.0167 (60 cuadros por seg.)
        var tiempoMovimiento = PERIODO_MOVIMIENTO;

        /***************************************************************************/
        /* Se crean, compilan y enlazan los programas Shader                       */
        /***************************************************************************/
        function compilaEnlazaLosShaders() {

          /* Se compila el shader de vertice */
          var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
          gl.compileShader(shaderDeVertice);
          if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(shaderDeVertice));
          }

          /* Se compila el shader de fragmento */
          var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
          gl.compileShader(shaderDeFragmento);
          if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
             console.error(gl.getShaderInfoLog(shaderDeFragmento));
          }

          /* Se enlaza ambos shader */
          programaID = gl.createProgram();
          gl.attachShader(programaID, shaderDeVertice); 
          gl.attachShader(programaID, shaderDeFragmento);
          gl.linkProgram(programaID);
          if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
             console.error(gl.getProgramInfoLog(programaID));
          }

          /* Se instala el programa de shaders para utilizarlo */
          gl.useProgram(programaID);
        }

        /***************************************************************************/
        /* Transformaciones mediante matrices                                      */
        /***************************************************************************/

        /* Convierte de grados a radianes */
        function toRadians(grados) {
          return grados * Math.PI / 180;
        };

        /* Matriz Identidad */ 
        function identidad(r) {
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslación - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
          var r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Escalación - glScalef */
        function escalacion(matriz, sx, sy, sz) { 
          var r = new Array(16);
          r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
          r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
          r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Rotación sobre X - glRotatef */
        function rotacionX(matriz, theta){
          let r = new Array(16);
          var c = Math.cos(toRadians(theta));
          var s = Math.sin(toRadians(theta));
          r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
          r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
          r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r); 
        }

        /* Rotación sobre Y - glRotatef */
        function rotacionY(matriz, theta){
          let r = new Array(16);
          var c = Math.cos(toRadians(theta));
          var s = Math.sin(toRadians(theta));
          r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
          r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
          r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }
	
        /* Rotación sobre Z - glRotatef */
        function rotacionZ(matriz, theta){
          let r = new Array(16);
          var c = Math.cos(toRadians(theta));
          var s = Math.sin(toRadians(theta));
          r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
          r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
          r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Proyección Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
          r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
          r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
          r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        /* Proyección Perspectiva - glFrustum */
        function frustum(r, izq, der, abj, arr, cerca, lejos) {
          r[0] = 2*cerca/(der-izq); r[4] =                 0; r[ 8] =          (der+izq)/(der-izq); r[12] =                            0;
          r[1] =                 0; r[5] = 2*cerca/(arr-abj); r[ 9] =          (arr+abj)/(arr-abj); r[13] =                            0;
          r[2] =                 0; r[6] =                 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2*lejos*cerca/(lejos-cerca);
          r[3] =                 0; r[7] =                 0; r[11] =                           -1; r[15] =                            0;
        }

        /* Proyección Perspectiva - gluPerspective */
        function perspective(r, fovy, aspecto, cerca, lejos) {
          var ang = fovy * 0.5;
          var f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
          r[0] = f/aspecto; r[4] = 0; r[ 8] =                                  0; r[12] =                                       0;
          r[1] =         0; r[5] = f; r[ 9] =                                  0; r[13] =                                       0;
          r[2] =         0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] =  -2.0 * lejos * cerca / (lejos - cerca);
          r[3] =         0; r[7] = 0; r[11] =                              - 1.0; r[15] =                                       0;
        }

        /* Multiplicación de matrices de 4 x 4 */
        function multiplica(c, a, b) {
          let r = new Array(16);
          let i, j, k;
          for (i = 0; i < 4; i++){
            for (j = 0; j < 4; j++){
              let s = 0;
              for (k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
                r[i + j * 4] = s;
              }
            }
          for (i = 0; i < 16; i++)
            c[i] = r[i];
        }

        /***********************************************************************************/
        /* Se define la geometría y se almacenan en los buffers de memoria y se renderiza. */
        /***********************************************************************************/
        class Cubo {
          constructor(gl) {

            /**
             *       3 --------- 2
             *       /|        /|   
             *      / |       / |
             *    7 --------- 6 |
             *     |  |      |  |
             *     | 0 ------|-- 1 
             *     | /       | /
             *     |/        |/
             *    4 --------- 5  
             */

            /* Las coordenadas cartesianas (x, y, z) */
            var vertices = [
               // Frente
               -1, -1,  1, // 4   0
                1, -1,  1, // 5   1
                1,  1,  1, // 6   2
               -1,  1,  1, // 7   3
               // Atrás
               -1,  1, -1, // 3   4
                1,  1, -1, // 2   5
                1, -1, -1, // 1   6
               -1, -1, -1, // 0   7
               // Izquierda
               -1, -1, -1, // 0   8
               -1, -1,  1, // 4   9
               -1,  1,  1, // 7  10 
               -1,  1, -1, // 3  11
               // Derecha
                1, -1,  1, // 5  12 
                1, -1, -1, // 1  13
                1,  1, -1, // 2  14
                1,  1,  1, // 6  15
               // Abajo
               -1, -1, -1, // 0  16
                1, -1, -1, // 1  17
                1, -1,  1, // 5  18
               -1, -1,  1, // 4  19
               // Arriba
               -1,  1,  1, // 7  20
                1,  1,  1, // 6  21
                1,  1, -1, // 2  22
               -1,  1, -1  // 3  23
            ];

            /* Los colores x c/vértice (r,g,b,a) */
            var colores = [
            // Frente - Pared (beige o marrón claro)
            0.9, 0.8, 0.7, 1,  // 4   0
            0.9, 0.8, 0.7, 1,  // 5   1
            0.9, 0.8, 0.7, 1,  // 6   2
            0.9, 0.8, 0.7, 1,  // 7   3
            // Atrás - Pared (beige o marrón claro)
            0.9, 0.8, 0.7, 1,  // 3   4
            0.9, 0.8, 0.7, 1,  // 2   5
            0.9, 0.8, 0.7, 1,  // 1   6
            0.9, 0.8, 0.7, 1,  // 0   7
            // Izquierda - Pared (beige o marrón claro)
            0.9, 0.8, 0.7, 1,  // 0   8
            0.9, 0.8, 0.7, 1,  // 4   9
            0.9, 0.8, 0.7, 1,  // 7  10
            0.9, 0.8, 0.7, 1,  // 3  11
            // Derecha - Pared (beige o marrón claro)
            0.9, 0.8, 0.7, 1,  // 5  12
            0.9, 0.8, 0.7, 1,  // 1  13
            0.9, 0.8, 0.7, 1,  // 2  14
            0.9, 0.8, 0.7, 1,  // 6  15
            // Abajo - Suelo (gris o marrón oscuro)
            0.6, 0.6, 0.6, 1,  // 0  16
            0.6, 0.6, 0.6, 1,  // 1  17
            0.6, 0.6, 0.6, 1,  // 5  18
            0.6, 0.6, 0.6, 1,  // 4  19
            // Arriba - Techo (rojo o marrón)
            0.8, 0.2, 0.2, 1,  // 7  20
            0.8, 0.2, 0.2, 1,  // 6  21
            0.8, 0.2, 0.2, 1,  // 2  22
            0.8, 0.2, 0.2, 1   // 3  23
        ];

            /* Indices */
            var indices = [ 
              0,  1,  2,  0,  2,  3, // Frente
              4,  5,  6,  4,  6,  7, // Atrás
              8,  9, 10,  8, 10, 11, // Izquierda 
             12, 13, 14, 12, 14, 15, // Derecha
             16, 17, 18, 16, 18, 19, // Abajo
             20, 21, 22, 20, 22, 23  // Arriba
            ];

            this.cuboVAO = gl.createVertexArray();
            gl.bindVertexArray(this.cuboVAO);

            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            var codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
            gl.bindVertexArray(this.cuboVAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }
        
        class Tronco {
          constructor(gl) {

            var vertices = [
             // Base del tronco (abajo)
              -0.2, 0.0, -0.2,    // Vértice 0
              0.2, 0.0, -0.2,    // Vértice 1
              0.2, 0.0,  0.2,    // Vértice 2
              -0.2, 0.0,  0.2,    // Vértice 3
              
              // Topo del tronco (arriba)
              -0.1, 1.0, -0.1,    // Vértice 4
              0.1, 1.0, -0.1,    // Vértice 5
              0.1, 1.0,  0.1,    // Vértice 6
              -0.1, 1.0,  0.1     // Vértice 7
            ];
            var colores= [
              0.55, 0.27, 0.07, 1.0,  // Vértice 0
              0.55, 0.27, 0.07, 1.0,  // Vértice 1
              0.55, 0.27, 0.07, 1.0,  // Vértice 2
              0.55, 0.27, 0.07, 1.0,  // Vértice 3
              0.55, 0.27, 0.07, 1.0,  // Vértice 4
              0.55, 0.27, 0.07, 1.0,  // Vértice 5
              0.55, 0.27, 0.07, 1.0,  // Vértice 6
              0.55, 0.27, 0.07, 1.0   // Vértice 7
            ];
            var indices= [
               // Frente
              0, 1, 5,    // Triángulo 1
              0, 5, 4,    // Triángulo 2
              
              // Atrás
              3, 2, 6,    // Triángulo 3
              3, 6, 7,    // Triángulo 4
              
              // Izquierda
              0, 3, 7,    // Triángulo 5
              0, 7, 4,    // Triángulo 6
              
              // Derecha
              1, 2, 6,    // Triángulo 7
              1, 6, 5,    // Triángulo 8
              
              // Abajo
              0, 1, 2,    // Triángulo 9
              0, 2, 3,    // Triángulo 10
              
              // Arriba
              4, 5, 6,    // Triángulo 11
              4, 6, 7 
            ];

            this.troncoVAO = gl.createVertexArray();
            gl.bindVertexArray(this.troncoVAO);

            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            var codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
            gl.bindVertexArray(this.troncoVAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }
    
        

        var avion;
        class Avion {
          constructor(gl) {
            // Vértices para construir un avión simplificado
            var vertices = [
              // Cuerpo principal (fuselaje)
              0.0, 0.0, 0.0,      // 0 - centro del avión
              0.0, 0.0, -1.0,     // 1 - nariz
              -0.2, 0.0, 0.0,     // 2 - lateral izquierdo
              0.2, 0.0, 0.0,      // 3 - lateral derecho
              0.0, 0.1, 0.0,      // 4 - parte superior
              0.0, -0.1, 0.0,     // 5 - parte inferior
              0.0, 0.0, 0.5,      // 6 - cola
              
              // Alas principales
              -0.8, 0.0, 0.0,     // 7 - punta izquierda ala
              -0.2, 0.0, 0.2,     // 8 - base izquierda ala
              0.2, 0.0, 0.2,      // 9 - base derecha ala
              0.8, 0.0, 0.0,      // 10 - punta derecha ala
              
              // Alas de cola
              -0.3, 0.0, 0.5,     // 11 - punta izquierda ala cola
              -0.1, 0.0, 0.3,     // 12 - base izquierda ala cola
              0.1, 0.0, 0.3,      // 13 - base derecha ala cola
              0.3, 0.0, 0.5,      // 14 - punta derecha ala cola
              
              // Estabilizador vertical
              0.0, 0.0, 0.5,      // 15 - base inferior estabilizador
              0.0, 0.3, 0.4,      // 16 - punta estabilizador
              0.0, 0.0, 0.3       // 17 - base frontal estabilizador
            ];
            
            // Colores para cada vértice
            var colores = [
              // Cuerpo - blanco con azul
              0.8, 0.8, 0.9, 1.0,  // 0
              0.8, 0.8, 0.9, 1.0,  // 1
              0.8, 0.8, 0.9, 1.0,  // 2
              0.8, 0.8, 0.9, 1.0,  // 3
              0.8, 0.8, 0.9, 1.0,  // 4
              0.8, 0.8, 0.9, 1.0,  // 5
              0.8, 0.8, 0.9, 1.0,  // 6
              
              // Alas - azul claro
              0.6, 0.6, 1.0, 1.0,  // 7
              0.6, 0.6, 1.0, 1.0,  // 8
              0.6, 0.6, 1.0, 1.0,  // 9
              0.6, 0.6, 1.0, 1.0,  // 10
              
              // Alas de cola - azul claro
              0.6, 0.6, 1.0, 1.0,  // 11
              0.6, 0.6, 1.0, 1.0,  // 12
              0.6, 0.6, 1.0, 1.0,  // 13
              0.6, 0.6, 1.0, 1.0,  // 14
              
              // Estabilizador vertical - rojo
              1.0, 0.4, 0.4, 1.0,  // 15
              1.0, 0.4, 0.4, 1.0,  // 16
              1.0, 0.4, 0.4, 1.0   // 17
            ];
            
            // Índices para formar triángulos
            var indices = [
              // Fuselaje - nariz
              0, 1, 2,
              0, 1, 3,
              0, 1, 4,
              0, 1, 5,
              
              // Fuselaje - cola
              0, 6, 2,
              0, 6, 3,
              0, 6, 4,
              0, 6, 5,
              
              // Alas principales
              0, 7, 8,
              0, 8, 9,
              0, 9, 10,
              
              // Alas cola
              0, 11, 12,
              0, 12, 13,
              0, 13, 14,
              
              // Estabilizador vertical
              0, 15, 16,
              0, 16, 17
            ];
            
            // Crear VAO y buffers
            this.avionVAO = gl.createVertexArray();
            gl.bindVertexArray(this.avionVAO);
            
            // Buffer de vértices
            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            
            // Buffer de colores
            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
            
            // Buffer de índices
            var codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            this.cantidadDeIndices = indices.length;
            
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
          
          dibuja(gl) {
            gl.bindVertexArray(this.avionVAO);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }


        var perrito
        class Perrito {
          constructor(gl) {
            // Definición de una versión simplificada de un perrito
            // Usando formas primitivas con transformaciones
            
            // El perrito se construye con componentes:
            // - Cuerpo (rectángulo)
            // - Cabeza (esfera)
            // - Patas (cilindros)
            // - Cola (cono)
            // - Orejas (triángulos)
            
            // Vértices para el modelo de perrito (estilo low poly)
            var vertices = [
              // Cuerpo principal (6 puntos - caja alargada)
              -0.3, 0.0, 0.1,    // 0 - frontal inferior izquierdo
              0.3, 0.0, 0.1,     // 1 - frontal inferior derecho
              -0.3, 0.2, 0.1,    // 2 - frontal superior izquierdo
              0.3, 0.2, 0.1,     // 3 - frontal superior derecho
              -0.3, 0.0, -0.1,   // 4 - trasero inferior izquierdo
              0.3, 0.0, -0.1,    // 5 - trasero inferior derecho
              -0.3, 0.2, -0.1,   // 6 - trasero superior izquierdo
              0.3, 0.2, -0.1,    // 7 - trasero superior derecho
              
              // Cabeza (8 puntos - caja)
              -0.5, 0.1, 0.05,   // 8 - frontal inferior izquierdo
              -0.3, 0.1, 0.05,   // 9 - frontal inferior derecho
              -0.5, 0.3, 0.05,   // 10 - frontal superior izquierdo
              -0.3, 0.3, 0.05,   // 11 - frontal superior derecho
              -0.5, 0.1, -0.05,  // 12 - trasero inferior izquierdo
              -0.3, 0.1, -0.05,  // 13 - trasero inferior derecho
              -0.5, 0.3, -0.05,  // 14 - trasero superior izquierdo
              -0.3, 0.3, -0.05,  // 15 - trasero superior derecho
              
              // Hocico (4 puntos adicionales)
              -0.6, 0.1, 0.03,   // 16 - frontal inferior
              -0.6, 0.1, -0.03,  // 17 - frontal inferior
              -0.6, 0.15, 0.03,  // 18 - frontal superior 
              -0.6, 0.15, -0.03, // 19 - frontal superior
              
              // Orejas (4 puntos)
              -0.4, 0.4, 0.05,   // 20 - oreja izquierda punta
              -0.5, 0.3, 0.05,   // 21 - oreja izquierda base
              -0.4, 0.4, -0.05,  // 22 - oreja derecha punta
              -0.5, 0.3, -0.05,  // 23 - oreja derecha base
              
              // Patas (12 puntos - 4 patas simples)
              -0.25, -0.2, 0.07, // 24 - pata frontal izquierda
              -0.25, 0.0, 0.07,  // 25
              -0.20, -0.2, 0.07, // 26
              
              0.25, -0.2, 0.07,  // 27 - pata frontal derecha
              0.25, 0.0, 0.07,   // 28
              0.20, -0.2, 0.07,  // 29
              
              -0.25, -0.2, -0.07, // 30 - pata trasera izquierda
              -0.25, 0.0, -0.07,  // 31
              -0.20, -0.2, -0.07, // 32
              
              0.25, -0.2, -0.07,  // 33 - pata trasera derecha
              0.25, 0.0, -0.07,   // 34
              0.20, -0.2, -0.07,  // 35
              
              // Cola (3 puntos)
              0.3, 0.1, 0.0,     // 36 - base
              0.5, 0.2, 0.0,     // 37 - punta
              0.3, 0.2, 0.0      // 38 - punto de control
            ];
            
            // Colores para cada vértice
            var colores = [];
            
            // Color marrón/beige para todo el perrito
            var colorCuerpo = [0.8, 0.6, 0.4, 1.0];
            var colorPatas = [0.6, 0.4, 0.2, 1.0];
            var colorOrejas = [0.7, 0.5, 0.3, 1.0];
            var colorCola = [0.75, 0.55, 0.35, 1.0];
            var colorHocico = [0.5, 0.3, 0.2, 1.0];
            
            // Asignar colores a los vértices
            // Cuerpo
            for (let i = 0; i < 8; i++) {
              colores = colores.concat(colorCuerpo);
            }
            
            // Cabeza
            for (let i = 0; i < 8; i++) {
              colores = colores.concat(colorCuerpo);
            }
            
            // Hocico
            for (let i = 0; i < 4; i++) {
              colores = colores.concat(colorHocico);
            }
            
            // Orejas
            for (let i = 0; i < 4; i++) {
              colores = colores.concat(colorOrejas);
            }
            
            // Patas
            for (let i = 0; i < 12; i++) {
              colores = colores.concat(colorPatas);
            }
            
            // Cola
            for (let i = 0; i < 3; i++) {
              colores = colores.concat(colorCola);
            }
            
            // Índices para formar triángulos
            var indices = [
              // Cuerpo - 12 triángulos (6 caras)
              0, 1, 3, 0, 3, 2,  // Frente
              4, 5, 7, 4, 7, 6,  // Atrás
              0, 2, 6, 0, 6, 4,  // Izquierda
              1, 3, 7, 1, 7, 5,  // Derecha
              2, 3, 7, 2, 7, 6,  // Arriba
              0, 1, 5, 0, 5, 4,  // Abajo
              
              // Cabeza - 12 triángulos
              8, 9, 11, 8, 11, 10,   // Frente
              12, 13, 15, 12, 15, 14, // Atrás
              8, 10, 14, 8, 14, 12,  // Izquierda
              9, 11, 15, 9, 15, 13,  // Derecha
              10, 11, 15, 10, 15, 14, // Arriba
              8, 9, 13, 8, 13, 12,   // Abajo
              
              // Hocico - 2 triángulos
              16, 17, 19, 16, 19, 18,
              
              // Orejas - 2 triángulos
              10, 20, 21,
              14, 22, 23,
              
              // Patas - 4 triángulos
              24, 25, 26,
              27, 28, 29,
              30, 31, 32,
              33, 34, 35,
              
              // Cola - 1 triángulo
              36, 37, 38
            ];
            
            // Crear VAO y buffers
            this.perritoVAO = gl.createVertexArray();
            gl.bindVertexArray(this.perritoVAO);
            
            // Buffer de vértices
            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            
            // Buffer de colores
            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
            
            // Buffer de índices
            var codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            this.cantidadDeIndices = indices.length;
            
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
          
          dibuja(gl) {
            gl.bindVertexArray(this.perritoVAO);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }


        var carro;
        class Carro {
          constructor(gl) {
            // Creamos un carro simplificado con formas básicas
            
            // Vértices para formar un carro
            var vertices = [
              // Cuerpo del carro (caja principal)
              -0.5, 0.0, 0.2,   // 0 - frontal inferior izquierdo
              0.5, 0.0, 0.2,    // 1 - frontal inferior derecho
              -0.5, 0.3, 0.2,   // 2 - frontal superior izquierdo
              0.5, 0.3, 0.2,    // 3 - frontal superior derecho
              -0.5, 0.0, -0.2,  // 4 - trasero inferior izquierdo
              0.5, 0.0, -0.2,   // 5 - trasero inferior derecho
              -0.5, 0.3, -0.2,  // 6 - trasero superior izquierdo
              0.5, 0.3, -0.2,   // 7 - trasero superior derecho
              
              // Cabina (parte superior)
              -0.3, 0.3, 0.15,  // 8 - frontal inferior izquierdo
              0.2, 0.3, 0.15,   // 9 - frontal inferior derecho
              -0.2, 0.5, 0.1,   // 10 - frontal superior izquierdo
              0.1, 0.5, 0.1,    // 11 - frontal superior derecho
              -0.3, 0.3, -0.15, // 12 - trasero inferior izquierdo
              0.2, 0.3, -0.15,  // 13 - trasero inferior derecho
              -0.2, 0.5, -0.1,  // 14 - trasero superior izquierdo
              0.1, 0.5, -0.1,   // 15 - trasero superior derecho
              
              // Ruedas (simplificadas como cuadrados)
              // Rueda frontal izquierda
              -0.35, -0.1, 0.21, // 16
              -0.15, -0.1, 0.21, // 17
              -0.35, 0.1, 0.21,  // 18
              -0.15, 0.1, 0.21,  // 19
              
              // Rueda frontal derecha
              0.15, -0.1, 0.21,  // 20
              0.35, -0.1, 0.21,  // 21
              0.15, 0.1, 0.21,   // 22
              0.35, 0.1, 0.21,   // 23
              
              // Rueda trasera izquierda
              -0.35, -0.1, -0.21, // 24
              -0.15, -0.1, -0.21, // 25
              -0.35, 0.1, -0.21,  // 26
              -0.15, 0.1, -0.21,  // 27
              
              // Rueda trasera derecha
              0.15, -0.1, -0.21,  // 28
              0.35, -0.1, -0.21,  // 29
              0.15, 0.1, -0.21,   // 30
              0.35, 0.1, -0.21    // 31
            ];
            
            // Colores para cada vértice
            var colores = [];
            
            // Colores para el carro
            var colorCuerpo = [0.8, 0.1, 0.1, 1.0]; // Rojo
            var colorCabina = [0.7, 0.7, 0.9, 1.0]; // Azul claro (ventanas)
            var colorRuedas = [0.1, 0.1, 0.1, 1.0]; // Negro
            
            // Asignar colores al cuerpo
            for (let i = 0; i < 8; i++) {
              colores = colores.concat(colorCuerpo);
            }
            
            // Asignar colores a la cabina
            for (let i = 0; i < 8; i++) {
              colores = colores.concat(colorCabina);
            }
            
            // Asignar colores a las ruedas
            for (let i = 0; i < 16; i++) {
              colores = colores.concat(colorRuedas);
            }
            
            // Índices para formar triángulos
            var indices = [
              // Cuerpo principal - 12 triángulos
              0, 1, 3, 0, 3, 2,  // Frente
              4, 5, 7, 4, 7, 6,  // Atrás
              0, 2, 6, 0, 6, 4,  // Izquierda
              1, 3, 7, 1, 7, 5,  // Derecha
              2, 3, 7, 2, 7, 6,  // Arriba
              0, 1, 5, 0, 5, 4,  // Abajo
              
              // Cabina - 12 triángulos
              8, 9, 11, 8, 11, 10,   // Frente
              12, 13, 15, 12, 15, 14, // Atrás
              8, 10, 14, 8, 14, 12,  // Izquierda
              9, 11, 15, 9, 15, 13,  // Derecha
              10, 11, 15, 10, 15, 14, // Arriba
              8, 9, 13, 8, 13, 12,   // Abajo
              
              // Ruedas - 8 triángulos (2 por rueda)
              // Rueda frontal izquierda
              16, 17, 19, 16, 19, 18,
              // Rueda frontal derecha
              20, 21, 23, 20, 23, 22,
              // Rueda trasera izquierda
              24, 25, 27, 24, 27, 26,
              // Rueda trasera derecha
              28, 29, 31, 28, 31, 30
            ];
            
            // Crear VAO y buffers
            this.carroVAO = gl.createVertexArray();
            gl.bindVertexArray(this.carroVAO);
            
            // Buffer de vértices
            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            
            // Buffer de colores
            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
            
            // Buffer de índices
            var codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            this.cantidadDeIndices = indices.length;
            
            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
          
          dibuja(gl) {
            gl.bindVertexArray(this.carroVAO);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }


        var sol;
        class Sol {
          constructor(gl, radio, cantidadDeLongitud, cantidadDeLatitud) {
            var i, j, kv = 0, kc = 0, ki = 0;

            this.radio = radio;
            this.cantidadDeLongitud = cantidadDeLongitud;
            this.cantidadDeLatitud = cantidadDeLatitud;

            var cantidadDeVertices = (cantidadDeLongitud + 1) * (cantidadDeLatitud + 1);
            var vertices = new Float32Array(cantidadDeVertices * 3);
            var colores = new Float32Array(cantidadDeVertices * 4);

            var cantidadDeTriangulos = 2 * cantidadDeLongitud * cantidadDeLatitud;
            this.cantidadDeIndices = cantidadDeTriangulos * 3;
            var indices = new Uint16Array(this.cantidadDeIndices);

            // === Generar vértices y colores cálidos (amarillo-anaranjado) ===
            for (j = 0; j <= cantidadDeLatitud; j++) {
                var latitud = j * Math.PI / cantidadDeLatitud;
                var sinLatitud = Math.sin(latitud);
                var cosLatitud = Math.cos(latitud);

                for (i = 0; i <= cantidadDeLongitud; i++) {
                    var longitud = i * 2 * Math.PI / cantidadDeLongitud;
                    var cosLongitud = Math.cos(longitud);
                    var senLongitud = Math.sin(longitud);

                    var x = radio * sinLatitud * cosLongitud;
                    var y = radio * cosLatitud;
                    var z = radio * sinLatitud * senLongitud;

                    vertices[kv++] = x;
                    vertices[kv++] = y;
                    vertices[kv++] = z;

                    // Color cálido para sol: combinación de amarillo y naranja
                    colores[kc++] = 1.0;         // Rojo
                    colores[kc++] = 0.75;        // Verde
                    colores[kc++] = 0.0;         // Azul (poca cantidad)
                    colores[kc++] = 1.0;         // Alfa
                }
            }

            // === Generar índices ===
            for (j = 0; j < cantidadDeLatitud; j++) {
                var latitudActual = j * (cantidadDeLongitud + 1);
                var latitudSiguiente = (j + 1) * (cantidadDeLongitud + 1);
                for (i = 0; i < cantidadDeLongitud; i++) {
                    var p1 = latitudActual + i;
                    var p2 = latitudActual + i + 1;
                    var p3 = latitudSiguiente + i;
                    var p4 = latitudSiguiente + i + 1;

                    indices[ki++] = p1;
                    indices[ki++] = p3;
                    indices[ki++] = p2;

                    indices[ki++] = p2;
                    indices[ki++] = p3;
                    indices[ki++] = p4;
                }
            }

            // === Buffers y VAO ===
            this.vao = gl.createVertexArray();
            gl.bindVertexArray(this.vao);

            this.vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            this.colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            this.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        dibuja(gl) {
            gl.bindVertexArray(this.vao);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
        }
    }






        var suelo;
        class Suelo {
          constructor(gl) {

            var vertices = [
          // Base del valle
          -3.0, -1.0, -3.0,    // Vértice 0
          3.0, -1.0, -3.0,     // Vértice 1
          3.0, -1.0, 3.0,      // Vértice 2
          -3.0, -1.0, 3.0,     // Vértice 3
          // Puntos superiores
          -2.0, 1.0, -2.0,     // Vértice 4
          2.0, 1.0, -2.0,      // Vértice 5
          2.0, 1.0, 2.0,       // Vértice 6
          -2.0, 1.0, 2.0       // Vértice 7
        ];
        var colores = [
          0.4, 0.3, 0.1, 1.0,  // Vértice 0   (Lodo oscuro)
          0.4, 0.3, 0.1, 1.0,  // Vértice 1   (Lodo oscuro)
          0.4, 0.3, 0.1, 1.0,  // Vértice 2   (Lodo oscuro)
          0.4, 0.3, 0.1, 1.0,  // Vértice 3   (Lodo oscuro)
          0.1, 0.4, 0.1, 1.0,  // Vértice 4   (Verde oscuro césped)
          0.1, 0.4, 0.1, 1.0,  // Vértice 5   (Verde oscuro césped)
          0.1, 0.4, 0.1, 1.0,  // Vértice 6   (Verde oscuro césped)
          0.1, 0.4, 0.1, 1.0   // Vértice 7   (Verde oscuro césped)
        ];
        var indices = [
          0, 1, 5,    // Cara frontal
          0, 5, 4,    // Cara frontal
          1, 2, 6,    // Cara derecha
          1, 6, 5,    // Cara derecha
          2, 3, 7,    // Cara posterior
          2, 7, 6,    // Cara posterior
          3, 0, 4,    // Cara izquierda
          3, 4, 7,    // Cara izquierda
          4, 5, 6,    // Cara superior
          4, 6, 7,    // Cara superior
          0, 1, 2,    // Base
          2, 3, 0     // Base
        ];


            this.troncoVAO = gl.createVertexArray();
            gl.bindVertexArray(this.troncoVAO);

            var codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            var codigoDeIndices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
            gl.bindVertexArray(this.troncoVAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }

        var rectangulo;
        class Rectangulo {
            constructor(gl, ancho, alto, profundidad) {
                var i, j, kv = 0, kc = 0, ki = 0;

                this.ancho = ancho;
                this.alto = alto;
                this.profundidad = profundidad;

                // 8 vértices para un cuboide
                var cantidadDeVertices = 8;
                var vertices = new Float32Array(cantidadDeVertices * 3);
                var colores = new Float32Array(cantidadDeVertices * 4);

                // 12 triángulos para un cuboide (2 por cara, 6 caras)
                var cantidadDeTriangulos = 12;
                this.cantidadDeIndices = cantidadDeTriangulos * 3;
                var indices = new Uint16Array(this.cantidadDeIndices);

                // Generación de vértices y colores
                // Cara frontal
                vertices[kv++] = -ancho / 2; vertices[kv++] = -alto / 2; vertices[kv++] = profundidad / 2;
                colores[kc++] = 0.7; colores[kc++] = 0.5; colores[kc++] = 0.2; colores[kc++] = 1;  // Café claro
                vertices[kv++] = ancho / 2;  vertices[kv++] = -alto / 2; vertices[kv++] = profundidad / 2;
                colores[kc++] = 0.7; colores[kc++] = 0.5; colores[kc++] = 0.2; colores[kc++] = 1;  // Café claro
                vertices[kv++] = ancho / 2;  vertices[kv++] = alto / 2;  vertices[kv++] = profundidad / 2;
                colores[kc++] = 0.5; colores[kc++] = 0.3; colores[kc++] = 0.1; colores[kc++] = 1;  // Café intermedio
                vertices[kv++] = -ancho / 2; vertices[kv++] = alto / 2;  vertices[kv++] = profundidad / 2;
                colores[kc++] = 0.5; colores[kc++] = 0.3; colores[kc++] = 0.1; colores[kc++] = 1;  // Café intermedio

                // Cara trasera
                vertices[kv++] = -ancho / 2; vertices[kv++] = -alto / 2; vertices[kv++] = -profundidad / 2;
                colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 0.05; colores[kc++] = 1; // Café oscuro
                vertices[kv++] = ancho / 2;  vertices[kv++] = -alto / 2; vertices[kv++] = -profundidad / 2;
                colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 0.05; colores[kc++] = 1; // Café oscuro
                vertices[kv++] = ancho / 2;  vertices[kv++] = alto / 2;  vertices[kv++] = -profundidad / 2;
                colores[kc++] = 0.3; colores[kc++] = 0.1; colores[kc++] = 0; colores[kc++] = 1;   // Café muy oscuro
                vertices[kv++] = -ancho / 2; vertices[kv++] = alto / 2;  vertices[kv++] = -profundidad / 2;
                colores[kc++] = 0.3; colores[kc++] = 0.1; colores[kc++] = 0; colores[kc++] = 1;   // Café muy oscuro

                // Generación de índices
                // Cara frontal
                indices[ki++] = 0; indices[ki++] = 1; indices[ki++] = 2;
                indices[ki++] = 2; indices[ki++] = 3; indices[ki++] = 0;

                // Cara trasera
                indices[ki++] = 4; indices[ki++] = 5; indices[ki++] = 6;
                indices[ki++] = 6; indices[ki++] = 7; indices[ki++] = 4;

                // Cara izquierda
                indices[ki++] = 4; indices[ki++] = 0; indices[ki++] = 3;
                indices[ki++] = 3; indices[ki++] = 7; indices[ki++] = 4;

                // Cara derecha
                indices[ki++] = 1; indices[ki++] = 5; indices[ki++] = 6;
                indices[ki++] = 6; indices[ki++] = 2; indices[ki++] = 1;

                // Cara inferior
                indices[ki++] = 0; indices[ki++] = 4; indices[ki++] = 5;
                indices[ki++] = 5; indices[ki++] = 1; indices[ki++] = 0;

                // Cara superior
                indices[ki++] = 3; indices[ki++] = 7; indices[ki++] = 6;
                indices[ki++] = 6; indices[ki++] = 2; indices[ki++] = 3;

                // Creación de buffers y VAO
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);

                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                this.colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }

            dibuja(gl) {
                gl.bindVertexArray(this.vao);
                gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
                gl.bindVertexArray(null);
            }
        }

        
          var cilindro;
          class Cilindro {
            constructor(gl, radioBase, alto, cantidadDeSectores, tapaSuperior, tapaInferior) {
              var i, j, kv = 0, kc = 0, ki = 0, angulo;
              var anguloDelSector = 2 * Math.PI / cantidadDeSectores;

              // Cantidad de vértices para los círculos (incluyendo el cierre)
              var cantidadDeVertices = 2 * (cantidadDeSectores + 1);
              if (tapaSuperior) cantidadDeVertices += 1; // Centro de la tapa superior
              if (tapaInferior) cantidadDeVertices += 1; // Centro de la tapa inferior

              // Cantidad de triángulos para el cuerpo y las tapas
              var cantidadDeTriangulos = 2 * cantidadDeSectores;
              if (tapaSuperior) cantidadDeTriangulos += cantidadDeSectores;
              if (tapaInferior) cantidadDeTriangulos += cantidadDeSectores;

              this.cantidadDeIndices = cantidadDeTriangulos * 3;

              var vertices = new Float32Array(cantidadDeVertices * 3);
              var colores = new Float32Array(cantidadDeVertices * 4);
              var indices = new Uint16Array(this.cantidadDeIndices);

              // Generar vértices del círculo de la base (abajo, z = -alto/2)
              for (i = 0; i <= cantidadDeSectores; i++) {
                angulo = i * anguloDelSector;
                var x = radioBase * Math.cos(angulo);
                var y = radioBase * Math.sin(angulo);
                vertices[kv++] = x;
                vertices[kv++] = y;
                vertices[kv++] = -alto / 2;
                colores[kc++] = 0.7; // Gris claro para la base
                colores[kc++] = 0.7;
                colores[kc++] = 0.7;
                colores[kc++] = 1;
              }

              // Generar vértices del círculo superior (arriba, z = alto/2)
              for (i = 0; i <= cantidadDeSectores; i++) {
                angulo = i * anguloDelSector;
                var x = radioBase * Math.cos(angulo); // Radio igual a la base
                var y = radioBase * Math.sin(angulo); // Radio igual a la base
                vertices[kv++] = x;
                vertices[kv++] = y;
                vertices[kv++] = alto / 2;
                colores[kc++] = 0.8; // Gris más claro para la parte superior
                colores[kc++] = 0.8;
                colores[kc++] = 0.8;
                colores[kc++] = 1;
              }

              // Generar índices para el cuerpo del cilindro
              for (i = 0; i < cantidadDeSectores; i++) {
                var abajo1 = i;
                var abajo2 = i + 1;
                var arriba1 = cantidadDeSectores + 1 + i;
                var arriba2 = cantidadDeSectores + 1 + i + 1;

                indices[ki++] = abajo1;
                indices[ki++] = arriba1;
                indices[ki++] = abajo2;

                indices[ki++] = abajo2;
                indices[ki++] = arriba1;
                indices[ki++] = arriba2;
              }

              // Generar vértice e índices para la tapa superior
              if (tapaSuperior) {
                var centroArriba = kv / 3;
                vertices[kv++] = 0;
                vertices[kv++] = 0;
                vertices[kv++] = alto / 2;
                colores[kc++] = 0.9;  // Casi blanco para el centro superior
                colores[kc++] = 0.9;
                colores[kc++] = 0.9;
                colores[kc++] = 1;
                var inicioCirculoArriba = cantidadDeSectores + 1;
                for (i = 0; i < cantidadDeSectores; i++) {
                  indices[ki++] = centroArriba;
                  indices[ki++] = inicioCirculoArriba + i + 1;
                  indices[ki++] = inicioCirculoArriba + i;
                }
              }

              // Generar vértice e índices para la tapa inferior
              if (tapaInferior) {
                var centroAbajo = kv / 3;
                vertices[kv++] = 0;
                vertices[kv++] = 0;
                vertices[kv++] = -alto / 2;
                colores[kc++] = 0.6;  // Gris más oscuro para el centro inferior
                colores[kc++] = 0.6;
                colores[kc++] = 0.6;
                colores[kc++] = 1;
                for (i = 0; i < cantidadDeSectores; i++) {
                  indices[ki++] = centroAbajo;
                  indices[ki++] = i;
                  indices[ki++] = i + 1;
                }
              }

              this.vao = gl.createVertexArray();
              gl.bindVertexArray(this.vao);

              this.vertexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
              gl.enableVertexAttribArray(0);
              gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

              this.colorBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
              gl.enableVertexAttribArray(1);
              gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

              this.indexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

              gl.bindVertexArray(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }

            dibuja(gl) {
              gl.bindVertexArray(this.vao);
              gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
              gl.bindVertexArray(null);
            }
          }

        var cono;
        class Cono {

          /* segmentosH = slices o longitud, segmentosV = stacks o latitud  */
          constructor(gl, radioBase, radioArriba, alto, cantidadDeSectores, tapaSuperior, tapaInferior) {

            var i, j, kv, kc, ki, angulo, x, y;

            var cantidadDeVertices = 2 * (cantidadDeSectores + 1) + (tapaSuperior ? (cantidadDeSectores + 1) + 1 : 0) + (tapaInferior ? (cantidadDeSectores + 1) + 1 : 0);
            var cantidadDeTriangulos = 2 * cantidadDeSectores + (tapaSuperior ? cantidadDeSectores : 0) + (tapaInferior ? cantidadDeSectores : 0);
            this.cantidadDeIndices = cantidadDeTriangulos * 3;

            /* Las coordenadas cartesianas (x, y, z) */
            var vertices = new Float32Array(cantidadDeVertices * 3);

            /* Los colores x c/vértice (r,g,b,a) */
            var colores = new Float32Array(cantidadDeVertices * 4);

            /* Indices */
            var indices = new Uint16Array(this.cantidadDeIndices);

            /* Se leen los vertices */
            kv = 0;
            kc = 0;
            var anguloDelSector = 2 * Math.PI / cantidadDeSectores; // 1 vuelta (en radianes)/cantidad de sectores

            // Circulo de abajo (base) en el plano XY, z = alto/2
            for (i = 0; i <= cantidadDeSectores; i++) {
              angulo = i * anguloDelSector;

              x = Math.cos(angulo);
              y = Math.sin(angulo);

              vertices[kv++] = radioBase * x;
              vertices[kv++] = radioBase * y;
              vertices[kv++] = alto / 2;

              colores[kc++] = 0.5;  // Marrón oscuro
              colores[kc++] = 0.3;
              colores[kc++] = 0.1;
              colores[kc++] = 1;
            }

            // Circulo de arriba en el plano XY, z = -alto/2
            for (i = 0; i <= cantidadDeSectores; i++) {
              angulo = i * anguloDelSector;

              x = Math.cos(angulo);
              y = Math.sin(angulo);

              vertices[kv++] = radioArriba * x;
              vertices[kv++] = radioArriba * y;
              vertices[kv++] = -alto / 2;

              colores[kc++] = 0.7;  // Marrón claro
              colores[kc++] = 0.5;
              colores[kc++] = 0.2;
              colores[kc++] = 1;
            }

            /* Se leen los indices */

            /**
             * cantidadDeSectores + 1 + j+1 ------- cantidadDeSectores + 1 + j
             * |                     / |
             * |                    /  |
             * |                   /   |
             * |                  /    |
             * j+1 --------- j
             *
             * j, cantidadDeSectores + 1 + j, j+1,   j+1, cantidadDeSectores + 1 + j, cantidadDeSectores + 1 + j + 1
             * =>  2 triangulos
             */
            ki = 0;
            let ki1 = 0;
            let ki2 = cantidadDeSectores + 1;
            for (j = 0; j < cantidadDeSectores; j++) {
              // Primer triangulo
              indices[ki++] = ki1;
              indices[ki++] = ki2 + 1;
              indices[ki++] = ki1 + 1;

              // Segundo triangulo
              indices[ki++] = ki1 + 1;
              indices[ki++] = ki2 + 1;
              indices[ki++] = ki2;

              ki1++;
              ki2++;
            }

            if (tapaSuperior) {
              // Centro de la tapa superior
              let p = kv / 3;
              vertices[kv++] = 0;
              vertices[kv++] = 0;
              vertices[kv++] = -alto / 2;

              colores[kc++] = 0.8;  // Gris oscuro
              colores[kc++] = 0.8;
              colores[kc++] = 0.8;
              colores[kc++] = 1;

              let p1 = cantidadDeSectores + 1;
              for (i = 0; i < cantidadDeSectores; i++) {
                indices[ki++] = p;
                indices[ki++] = p1 + i + 1;
                indices[ki++] = p1 + i;
              }
            }

            if (tapaInferior) {
              // Centro de la tapa inferior
              let p = kv / 3;
              vertices[kv++] = 0;
              vertices[kv++] = 0;
              vertices[kv++] = alto / 2;

              colores[kc++] = 0.6;  // Gris medio
              colores[kc++] = 0.6;
              colores[kc++] = 0.6;
              colores[kc++] = 1;

              let p1 = 0;
              for (i = 0; i < cantidadDeSectores; i++) {
                indices[ki++] = p;
                indices[ki++] = p1 + i;
                indices[ki++] = p1 + i + 1;
              }
            }

            console.log("Cant. triangulos: ", cantidadDeTriangulos);
            console.log("Cant. vertices: ", cantidadDeVertices);
            console.log("vertices: ", vertices.length / 3);
            for (let i = 0; i < vertices.length; i += 3) {
              console.log(i / 3 + " : " + vertices[i] + "  " + vertices[i + 1] + "  " + vertices[i + 2])
            }

            console.log("indices: ", indices.length);
            for (let i = 0; i < indices.length; i += 3) {
              console.log(i + " : " + indices[i] + "  " + indices[i + 1] + "  " + indices[i + 2])
            }

            this.cilindroVAO = gl.createVertexArray();
            gl.bindVertexArray(this.cilindroVAO);

            var verticeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            var indiceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
            gl.bindVertexArray(this.cilindroVAO);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }

        var paraboloide;
        class Paraboloide {
            constructor(gl, radio, alto, cantidadDeSectores, cantidadDeStacks, tapa) {
                var i, j, kv = 0, kc = 0, ki = 0;

                this.cantidadDeSectores = cantidadDeSectores;
                this.cantidadDeStacks = cantidadDeStacks;
                this.tapa = tapa;

                // Vértices y colores
                var cantidadDeVertices = (cantidadDeSectores + 1) * (cantidadDeStacks + 1);
                if (tapa) {
                    cantidadDeVertices += 1; // Centro de la tapa
                }
                var vertices = new Float32Array(cantidadDeVertices * 3);
                var colores = new Float32Array(cantidadDeVertices * 4);

                // Índices
                var cantidadDeTriangulos = 2 * cantidadDeSectores * cantidadDeStacks;
                if (tapa) {
                    cantidadDeTriangulos += cantidadDeSectores;
                }
                this.cantidadDeIndices = cantidadDeTriangulos * 3;
                var indices = new Uint16Array(this.cantidadDeIndices);

                // Altura de cada stack
                var alturaStack = alto / cantidadDeStacks;

             // Generación de vértices y colores
              for (j = 0; j <= cantidadDeStacks; j++) {
                  var z = j * alto / cantidadDeStacks - alto / 2;
                  var r = radio * Math.sqrt(j / cantidadDeStacks); // Radio varía con la raíz cuadrada de la altura
                  for (i = 0; i <= cantidadDeSectores; i++) {
                      var angulo = i * 2 * Math.PI / cantidadDeSectores;
                      var x = r * Math.cos(angulo);
                      var y = r * Math.sin(angulo);

                      vertices[kv++] = x;
                      vertices[kv++] = y;
                      vertices[kv++] = z;

                      // Colores de montaña: marrones en la base, verdes en el medio, blancos en la cima
                      let alturaNormalizada = j / cantidadDeStacks; // 0 en la base, 1 en la cima

                      let marronOscuro = [0.4, 0.2, 0.1];
                      let marronClaro = [0.6, 0.4, 0.2];
                      let verdeOscuro = [0.1, 0.5, 0.1];
                      let verdeClaro = [0.3, 0.7, 0.3];
                      let blanco = [0.9, 0.9, 0.9];

                      let rColor, gColor, bColor;

                      if (alturaNormalizada < 0.2) { // Base: tonos marrones
                          let mezcla = alturaNormalizada / 0.2;
                          rColor = blanco[0] * (1 - mezcla) + marronClaro[0] * mezcla;
                          gColor = blanco[1] * (1 - mezcla) + marronClaro[1] * mezcla;
                          bColor = blanco[2] * (1 - mezcla) + marronClaro[2] * mezcla;
                      } else if (alturaNormalizada < 0.8) { // Medio: tonos verdes
                          let mezcla = (alturaNormalizada - 0.2) / 0.6;
                          rColor = verdeOscuro[0] * (1 - mezcla) + verdeClaro[0] * mezcla;
                          gColor = verdeOscuro[1] * (1 - mezcla) + verdeClaro[1] * mezcla;
                          bColor = verdeOscuro[2] * (1 - mezcla) + verdeClaro[2] * mezcla;
                      } else { // Cima: tonos blancos
                          let mezcla = (alturaNormalizada - 0.8) / 0.2;
                          rColor = verdeClaro[0] * (1 - mezcla) + marronOscuro[0] * mezcla;
                          gColor = verdeClaro[1] * (1 - mezcla) + marronOscuro[1] * mezcla;
                          bColor = verdeClaro[2] * (1 - mezcla) + marronOscuro[2] * mezcla;
                      }

                      colores[kc++] = rColor;
                      colores[kc++] = gColor;
                      colores[kc++] = bColor;
                      colores[kc++] = 1;
                  }
              }

                // Generación de índices
                ki = 0;
                for (j = 0; j < cantidadDeStacks; j++) {
                    var filaActual = j * (cantidadDeSectores + 1);
                    var filaSiguiente = (j + 1) * (cantidadDeSectores + 1);
                    for (i = 0; i < cantidadDeSectores; i++) {
                        var p1 = filaActual + i;
                        var p2 = filaActual + i + 1;
                        var p3 = filaSiguiente + i;
                        var p4 = filaSiguiente + i + 1;

                        indices[ki++] = p1;
                        indices[ki++] = p3;
                        indices[ki++] = p2;

                        indices[ki++] = p2;
                        indices[ki++] = p3;
                        indices[ki++] = p4;
                    }
                }

                // Generar tapa si es necesario
                if (tapa) {
                    var centroTapa = kv / 3;
                    vertices[kv++] = 0;
                    vertices[kv++] = 0;
                    vertices[kv++] = -alto / 2; // La tapa está en la base

                    colores[kc++] = 0.5;
                    colores[kc++] = 0.5;
                    colores[kc++] = 0.5;
                    colores[kc++] = 1;

                    var inicioCirculoTapa = 0; // El primer círculo de vértices es la base
                    for (i = 0; i < cantidadDeSectores; i++) {
                        indices[ki++] = centroTapa;
                        indices[ki++] = inicioCirculoTapa + i + 1;
                        indices[ki++] = inicioCirculoTapa + i;
                    }
                }

                // Creación de buffers y VAO
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);

                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                this.colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }

            dibuja(gl) {
                gl.bindVertexArray(this.vao);
                gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
                gl.bindVertexArray(null);
            }
        }

       var esfera;
        class Esfera {
            constructor(gl, radio, cantidadDeLongitud, cantidadDeLatitud) {
                var i, j, kv = 0, kc = 0, ki = 0;

                this.radio = radio;
                this.cantidadDeLongitud = cantidadDeLongitud; // Divisiones a lo largo del meridiano
                this.cantidadDeLatitud = cantidadDeLatitud; // Divisiones a lo largo del paralelo

                // Vértices y colores
                var cantidadDeVertices = (cantidadDeLongitud + 1) * (cantidadDeLatitud + 1);
                var vertices = new Float32Array(cantidadDeVertices * 3);
                var colores = new Float32Array(cantidadDeVertices * 4);

                // Índices
                var cantidadDeTriangulos = 2 * cantidadDeLongitud * cantidadDeLatitud;
                this.cantidadDeIndices = cantidadDeTriangulos * 3;
                var indices = new Uint16Array(this.cantidadDeIndices);

                 // Generación de vértices y colores
                for (j = 0; j <= cantidadDeLatitud; j++) {
                    var latitud = j * Math.PI / cantidadDeLatitud;
                    var sinLatitud = Math.sin(latitud);
                    var cosLatitud = Math.cos(latitud);
                    for (i = 0; i <= cantidadDeLongitud; i++) {
                        var longitud = i * 2 * Math.PI / cantidadDeLongitud;
                        var cosLongitud = Math.cos(longitud);
                        var senLongitud = Math.sin(longitud);

                        var x = radio * sinLatitud * cosLongitud;
                        var y = radio * cosLatitud;
                        var z = radio * sinLatitud * senLongitud;

                        vertices[kv++] = x;
                        vertices[kv++] = y;
                        vertices[kv++] = z;

                        // Verde oscuro en la parte inferior, verde claro en la superior
                        let verdeOscuro = [0.1, 0.5, 0.1]; // Ejemplo: verde bosque
                        let verdeClaro = [0.6, 0.8, 0.4]; // Ejemplo: verde lima

                        let mezcla = (y + radio) / (2 * radio); // Mapear y al rango [0, 1]

                        let r = verdeOscuro[0] * (1 - mezcla) + verdeClaro[0] * mezcla;
                        let g = verdeOscuro[1] * (1 - mezcla) + verdeClaro[1] * mezcla;
                        let b = verdeOscuro[2] * (1 - mezcla) + verdeClaro[2] * mezcla;

                        colores[kc++] = r;
                        colores[kc++] = g;
                        colores[kc++] = b;
                        colores[kc++] = 1;
                    }
                }
        


                // Generación de índices
                ki = 0;
                for (j = 0; j < cantidadDeLatitud; j++) {
                    var latitudActual = j * (cantidadDeLongitud + 1);
                    var latitudSiguiente = (j + 1) * (cantidadDeLongitud + 1);
                    for (i = 0; i < cantidadDeLongitud; i++) {
                        var p1 = latitudActual + i;
                        var p2 = latitudActual + i + 1;
                        var p3 = latitudSiguiente + i;
                        var p4 = latitudSiguiente + i + 1;

                        indices[ki++] = p1;
                        indices[ki++] = p3;
                        indices[ki++] = p2;

                        indices[ki++] = p2;
                        indices[ki++] = p3;
                        indices[ki++] = p4;
                    }
                }

                // Creación de buffers y VAO
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);

                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

                this.colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                gl.bindVertexArray(null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }

            dibuja(gl) {
                gl.bindVertexArray(this.vao);
                gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
                gl.bindVertexArray(null);
            }
        }

      var trapezoide;
        class Trapezoide {
          constructor(gl, baseMenor, baseMayor, altura, profundidad) {
              var i, j, kv = 0, kc = 0, ki = 0;

              this.baseMenor = baseMenor;
              this.baseMayor = baseMayor;
              this.altura = altura;
              this.profundidad = profundidad;

              // 8 vértices para un trapezoide (similar a un cuboide, pero con la base superior menor)
              var cantidadDeVertices = 8;
              var vertices = new Float32Array(cantidadDeVertices * 3);
              var colores = new Float32Array(cantidadDeVertices * 4);

              // 12 triángulos (2 por cara, 6 caras)
              var cantidadDeTriangulos = 12;
              this.cantidadDeIndices = cantidadDeTriangulos * 3;
              var indices = new Uint16Array(this.cantidadDeIndices);

              // Calcular las diferencias entre las bases para las coordenadas x
              let diffBases = (baseMayor - baseMenor) / 2;

              // Generación de vértices y colores
                     // Cara frontal
                     vertices[kv++] = -baseMayor / 2; vertices[kv++] = -altura / 2; vertices[kv++] = profundidad / 2; // 0
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;  // Marrón claro
                     vertices[kv++] = baseMayor / 2;   vertices[kv++] = -altura / 2; vertices[kv++] = profundidad / 2; // 1
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;
                     vertices[kv++] = baseMenor / 2;   vertices[kv++] = altura / 2;   vertices[kv++] = profundidad / 2; // 2
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;
                     vertices[kv++] = -baseMenor / 2; vertices[kv++] = altura / 2;   vertices[kv++] = profundidad / 2; // 3
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;

                     // Cara trasera
                     vertices[kv++] = -baseMayor / 2; vertices[kv++] = -altura / 2; vertices[kv++] = -profundidad / 2; // 4
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;
                     vertices[kv++] = baseMayor / 2;   vertices[kv++] = -altura / 2; vertices[kv++] = -profundidad / 2; // 5
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;
                     vertices[kv++] = baseMenor / 2;   vertices[kv++] = altura / 2;   vertices[kv++] = -profundidad / 2; // 6
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;
                     vertices[kv++] = -baseMenor / 2; vertices[kv++] = altura / 2;   vertices[kv++] = -profundidad / 2; // 7
                     colores[kc++] = 0.6; colores[kc++] = 0.4; colores[kc++] = 0.2; colores[kc++] = 1;
              // Generación de índices (igual que el cuboide)
              // Cara frontal
              indices[ki++] = 0; indices[ki++] = 1; indices[ki++] = 2;
              indices[ki++] = 2; indices[ki++] = 3; indices[ki++] = 0;

              // Cara trasera
              indices[ki++] = 4; indices[ki++] = 5; indices[ki++] = 6;
              indices[ki++] = 6; indices[ki++] = 7; indices[ki++] = 4;

              // Cara izquierda
              indices[ki++] = 4; indices[ki++] = 0; indices[ki++] = 3;
              indices[ki++] = 3; indices[ki++] = 7; indices[ki++] = 4;

              // Cara derecha
              indices[ki++] = 1; indices[ki++] = 5; indices[ki++] = 6;
              indices[ki++] = 6; indices[ki++] = 2; indices[ki++] = 1;

              // Cara inferior
              indices[ki++] = 0; indices[ki++] = 4; indices[ki++] = 5;
              indices[ki++] = 5; indices[ki++] = 1; indices[ki++] = 0;

              // Cara superior
              indices[ki++] = 3; indices[ki++] = 7; indices[ki++] = 6;
              indices[ki++] = 6; indices[ki++] = 2; indices[ki++] = 3;

              // Creación de buffers y VAO (igual que el cuboide)
              this.vao = gl.createVertexArray();
              gl.bindVertexArray(this.vao);

              this.vertexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
              gl.enableVertexAttribArray(0);
              gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

              this.colorBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
              gl.enableVertexAttribArray(1);
              gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

              this.indexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

              gl.bindVertexArray(null);
              gl.bindBuffer(gl.ARRAY_BUFFER, null);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
              gl.bindVertexArray(this.vao);
              gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
              gl.bindVertexArray(null);
          }
      }

       // Variables globales adicionales
        var personaje;
        var velocidad = 0.1;
        var posicionX = 0;
        var posicionZ = 0;
        var rotacion = 0;

       
        function dibuja() {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          escalacion(MatrizModelo, 3, 3, 2.5);
          traslacion(MatrizModelo, -1.5,-0.2,-1);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          tronco.dibuja(gl);
          
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo,24+rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 3, 3, 3);
          traslacion(MatrizModelo, -0.2,2.1,1);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          avion.dibuja(gl);


          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          escalacion(MatrizModelo, 3, 3, 3.5);
          traslacion(MatrizModelo, 2,2,1);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          sol.dibuja(gl);


          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          escalacion(MatrizModelo, 1, 1,2);
          traslacion(MatrizModelo, -4,-0.23,-0.4);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          perrito.dibuja(gl);

          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          escalacion(MatrizModelo, 3, 2,4);
          traslacion(MatrizModelo, -0.1,0.17,0.4);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          carro.dibuja(gl);

          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 2.5, 0.7, 1.7);
          traslacion(MatrizModelo, 0,-0.9,0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          suelo.dibuja(gl);

          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 1.5, 0.7, 1.7);
          traslacion(MatrizModelo, 2.5,1,0.5);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          cubo.dibuja(gl);
          
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 0.5, 0.5, 0.7);
          traslacion(MatrizModelo, -8.5,6.2,-3.5);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          esfera.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 0.1, 0.1, 0.1);
          traslacion(MatrizModelo, -20,6,0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 0.1, 0.1, 0.1);
          traslacion(MatrizModelo, -20,4.5,0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 0.1, 0.1, 0.1);
          traslacion(MatrizModelo, -20,3.1,0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 0.1, 0.1, 0.1);
          traslacion(MatrizModelo, -20,3.1,1.4);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 0.1, 0.1, 0.1);
          traslacion(MatrizModelo, -20,3.1,2.9);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, -0.02, 1.3, 0.1);
          traslacion(MatrizModelo, 90,0,0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, -0.02, 1.3, 0.1);
          traslacion(MatrizModelo, 110,0,0);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, -0.02, 0.7, 0.1);
          traslacion(MatrizModelo, 110,0,3);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);
          
          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, -0.02, 0.7, 0.1);
          traslacion(MatrizModelo, 90,0,3);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          rectangulo.dibuja(gl);

          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionX(MatrizModelo, 90);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 1.5, 1.95, 3.7);
          traslacion(MatrizModelo, 2.6,-1.90,-0.9);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          paraboloide.dibuja(gl);

          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionX(MatrizModelo,90);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 1.3, 1.3, 0.5);
          traslacion(MatrizModelo, 0.90,-1.90,-6.5);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          cono.dibuja(gl);

          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionX(MatrizModelo,90);
          rotacionZ(MatrizModelo, 7);
          escalacion(MatrizModelo, 1.2, 1.2, 0.7);
          traslacion(MatrizModelo, 1,-1.9,-1.8);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          cilindro.dibuja(gl);

          identidad(MatrizModelo);
          rotacionY(MatrizModelo, rotX);
          rotacionX(MatrizModelo, rotY);
          rotacionX(MatrizModelo, 180);
          rotacionZ(MatrizModelo, -7);
          escalacion(MatrizModelo, 1, 0.5, 1.9);
          traslacion(MatrizModelo, 3.8,-3.8,-0.45);
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

          trapezoide.dibuja(gl);


          /* Se efectua loa incrementos para la animación */
          fin = Date.now(); // Tiempo Final
          duracion = fin - inicio;
          inicio = fin;
          tiempo_real = duracion / 1000.0;
            if (boton_izq_presionado==false) {
          tiempoMovimiento = tiempoMovimiento - tiempo_real;
          if (tiempoMovimiento < 0.001) { 
            tiempoMovimiento = PERIODO_MOVIMIENTO;
            rotX = rotX + INCX;
            //rotY = rotY + INCY;
            //rotZ = rotZ + INCZ;
          }
        }

          /* Solicita que el navegador llame nuevamente a dibuja */
          requestAnimationFrame(dibuja);
        }

        /***************************************************************************/
        /* Eventos del Ratón                                                       */
        /***************************************************************************/

        function mouseDown(event) {
          var posx = new Number();
          var posy = new Number();

          /* Obtiene la coordenada dentro de la área mayor */
          if (event.x != undefined && event.y != undefined) {
            posx = event.x;
            posy = event.y;
          } else {
            posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
          }

          /* Obtiene la coordenada dentro del canvas */
          posx = posx - canvas.offsetLeft;
          posy = posy - canvas.offsetTop;

          antX = posx;
          antY = posy;

          boton_izq_presionado = true;

          return false;
        };

        function mouseUp(e){
          boton_izq_presionado = false;
        };

        function mouseMove(event) {

          if (!boton_izq_presionado)
            return false;

          var posx = new Number();
          var posy = new Number();

          /* Obtiene la coordenada dentro de la área mayor */
          if (event.x != undefined && event.y != undefined) {
            posx = event.x;
            posy = event.y;
          } else {
            posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
          }

          /* Obtiene la coordenada dentro del canvas */
          posx = posx - canvas.offsetLeft;
          posy = posy - canvas.offsetTop;

          var dx = posx - antX;
          var dy = posy - antY;

          rotX = rotX + dx * 0.36; // 180 / 500 = 0.36
          rotY = rotY + dy * 0.36;

          antX = posx;
          antY = posy;

        };

        function main() {
          canvas = document.getElementById("webglcanvas");
          gl = canvas.getContext("webgl2");
          if (!gl) {
             document.write("WebGL 2.0 no está disponible en tu navegador");
             return;
          }

          /* Para detectar los eventos del ratón */
          canvas.addEventListener("mousedown", mouseDown, false);
          canvas.addEventListener("mouseup", mouseUp, false);
          canvas.addEventListener("mouseout", mouseUp, false);
          canvas.addEventListener("mousemove", mouseMove, false);

            // Eventos de teclado para el personaje
            document.addEventListener('keydown', function(e) {
                switch(e.key) {
                case 'ArrowUp':
                    posicionZ -= velocidad;
                    rotacion = 0;
                    break;
                case 'ArrowDown':
                    posicionZ += velocidad;
                    rotacion = Math.PI;
                    break;
                case 'ArrowLeft':
                    posicionX -= velocidad;
                    rotacion = -Math.PI/2;
                    break;
                case 'ArrowRight':
                    posicionX += velocidad;
                    rotacion = Math.PI/2;
                    break;
                }
            });

          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
          compilaEnlazaLosShaders();

          cubo = new Cubo(gl);
          tronco = new Tronco(gl);
          suelo = new Suelo(gl);
          rectangulo = new Rectangulo(gl, 7, 1, 1);
          cilindro = new Cilindro(gl, 0.7, 4, 10, true, true);
          cono = new Cono(gl, 1, 0, 4, 24, true, true);
          paraboloide = new Paraboloide(gl, 1, 2, 10, 7, true); 
          esfera = new Esfera(gl, 3, 50, 50);
          trapezoide = new Trapezoide(gl, 4, 1, 2, 2);
          avion = new Avion(gl);
          sol = new Sol(gl, 0.5,10,10);
          perrito = new Perrito(gl, 1, 1, 1);
          carro = new Carro(gl, 1, 1, 1);


          gl.useProgram(programaID);
          uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
          uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
          uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
          
          //ortho(MatrizProyeccion, -5, 5, -5, 5, -5, 5);
          ortho(MatrizProyeccion, -10 * gl.canvas.width/gl.canvas.height,  10 * gl.canvas.width/gl.canvas.height, -10, 10, -10, 10);

          gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
          identidad(MatrizVista);
          gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
          gl.enable(gl.DEPTH_TEST);
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          dibuja();
        }
        window.onload = main;
      </script>
   </body>
</html>